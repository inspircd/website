<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>InspIRCd: CommandParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">InspIRCd
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_command_parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CommandParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="command__parse_8h_source.html">command_parse.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1fd17c361d85ec13c212cbac1999b9b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a1fd17c361d85ec13c212cbac1999b9b3">CommandParser</a> ()</td></tr>
<tr class="separator:a1fd17c361d85ec13c212cbac1999b9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd3cd9292c6d9a4380b8aba363b3250"><td class="memItemLeft" align="right" valign="top">CmdResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a8cd3cd9292c6d9a4380b8aba363b3250">CallHandler</a> (const std::string &amp;commandname, const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="separator:a8cd3cd9292c6d9a4380b8aba363b3250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c230220609e9ba68025dd90a8de8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_command.html">Command</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#af7c230220609e9ba68025dd90a8de8db">GetHandler</a> (const std::string &amp;commandname)</td></tr>
<tr class="separator:af7c230220609e9ba68025dd90a8de8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95915828b7eec4be567b7c1a44ca231"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#ad95915828b7eec4be567b7c1a44ca231">IsValidCommand</a> (const std::string &amp;commandname, unsigned int pcnt, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="separator:ad95915828b7eec4be567b7c1a44ca231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea01eecab7594381b8ac8f01a21bf42e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#aea01eecab7594381b8ac8f01a21bf42e">LoopCall</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_command.html">Command</a> *CommandObj, const std::vector&lt; std::string &gt; &amp;parameters, unsigned int splithere, int extra=-1, bool usemax=true)</td></tr>
<tr class="separator:aea01eecab7594381b8ac8f01a21bf42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9abf365c85ef9989d768c64d9913769"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#aa9abf365c85ef9989d768c64d9913769">ProcessBuffer</a> (std::string &amp;buffer, <a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:aa9abf365c85ef9989d768c64d9913769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192f037306b2eec9044944cc1f47268f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a192f037306b2eec9044944cc1f47268f">AddCommand</a> (<a class="el" href="class_command.html">Command</a> *f)</td></tr>
<tr class="separator:a192f037306b2eec9044944cc1f47268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3c5995f2cd122b66ff9be652be04d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a2d3c5995f2cd122b66ff9be652be04d6">RemoveCommand</a> (<a class="el" href="class_command.html">Command</a> *x)</td></tr>
<tr class="separator:a2d3c5995f2cd122b66ff9be652be04d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8a07557d89569088b15e9a0277c0f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#aac8a07557d89569088b15e9a0277c0f8">TranslateUIDs</a> (TranslateType to, const std::string &amp;source, std::string &amp;dest)</td></tr>
<tr class="separator:aac8a07557d89569088b15e9a0277c0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f208f21f81bf4fe661cc7512ae02f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a15f208f21f81bf4fe661cc7512ae02f3">TranslateUIDs</a> (const std::vector&lt; TranslateType &gt; to, const std::vector&lt; std::string &gt; &amp;source, std::string &amp;dest, bool prefix_final=false, <a class="el" href="class_command.html">Command</a> *custom_translator=NULL)</td></tr>
<tr class="separator:a15f208f21f81bf4fe661cc7512ae02f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8f0d1a1ef53adbf6d364a66051acd7d1"><td class="memItemLeft" align="right" valign="top">Commandtable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a8f0d1a1ef53adbf6d364a66051acd7d1">cmdlist</a></td></tr>
<tr class="separator:a8f0d1a1ef53adbf6d364a66051acd7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class handles command management and parsing. It allows you to add and remove commands from the map, call command handlers by name, and chop up comma seperated parameters into multiple calls. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1fd17c361d85ec13c212cbac1999b9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd17c361d85ec13c212cbac1999b9b3">&#9670;&nbsp;</a></span>CommandParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CommandParser::CommandParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a192f037306b2eec9044944cc1f47268f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192f037306b2eec9044944cc1f47268f">&#9670;&nbsp;</a></span>AddCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandParser::AddCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command.html">Command</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new command to the commands hash </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The new <a class="el" href="class_command.html">Command</a> to add to the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command was added </dd></dl>

</div>
</div>
<a id="a8cd3cd9292c6d9a4380b8aba363b3250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd3cd9292c6d9a4380b8aba363b3250">&#9670;&nbsp;</a></span>CallHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CmdResult CommandParser::CallHandler </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>commandname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the handler for a given command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandname</td><td>The command to find. This should be in uppercase. </td></tr>
    <tr><td class="paramname">parameters</td><td>Parameter list </td></tr>
    <tr><td class="paramname">user</td><td>The user to call the handler on behalf of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This method will return CMD_SUCCESS if the command handler was found and called, and the command completeld successfully. It will return CMD_FAILURE if the command handler was found and called, but the command did not complete successfully, and it will return CMD_INVALID if the command simply did not exist at all or the wrong number of parameters were given, or the user was not privilaged enough to execute the command. </dd></dl>

</div>
</div>
<a id="af7c230220609e9ba68025dd90a8de8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c230220609e9ba68025dd90a8de8db">&#9670;&nbsp;</a></span>GetHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_command.html">Command</a> * CommandParser::GetHandler </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>commandname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the handler function for a command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandname</td><td>The command required. Always use uppercase for this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the command handler, or NULL </dd></dl>

</div>
</div>
<a id="ad95915828b7eec4be567b7c1a44ca231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95915828b7eec4be567b7c1a44ca231">&#9670;&nbsp;</a></span>IsValidCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandParser::IsValidCommand </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>commandname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns true if a command is valid with the given number of parameters and user. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandname</td><td>The command name to check </td></tr>
    <tr><td class="paramname">pcnt</td><td>The parameter count </td></tr>
    <tr><td class="paramname">user</td><td>The user to check against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the user given has permission to execute the command, and the parameter count is equal to or greater than the minimum number of parameters to the given command, then this function will return true, otherwise it will return false. </dd></dl>

</div>
</div>
<a id="aea01eecab7594381b8ac8f01a21bf42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea01eecab7594381b8ac8f01a21bf42e">&#9670;&nbsp;</a></span>LoopCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CommandParser::LoopCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_command.html">Command</a> *&#160;</td>
          <td class="paramname"><em>CommandObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>splithere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extra</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usemax</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LoopCall is used to call a command classes handler repeatedly based on the contents of a comma seperated list. There are two overriden versions of this method, one of which takes two potential lists and the other takes one. We need a version which takes two potential lists for JOIN, because a JOIN may contain two lists of items at once, the channel names and their keys as follows:</p>
<p>JOIN #chan1,#chan2,#chan3 key1,,key3</p>
<p>Therefore, we need to deal with both lists concurrently. The first instance of this method does that by creating two instances of <a class="el" href="classirc_1_1commasepstream.html">irc::commasepstream</a> and reading them both together until the first runs out of tokens. The second version is much simpler and just has the one stream to read, and is used in NAMES, WHOIS, PRIVMSG etc. Both will only parse until they reach ServerInstance-&gt;Config-&gt;MaxTargets number of targets, to stop abuse via spam.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who sent the command </td></tr>
    <tr><td class="paramname">CommandObj</td><td>the command object to call for each parameter in the list </td></tr>
    <tr><td class="paramname">parameters</td><td>Parameter list as an array of array of char (that's not a typo). </td></tr>
    <tr><td class="paramname">splithere</td><td>The first parameter index to split as a comma seperated list </td></tr>
    <tr><td class="paramname">extra</td><td>The second parameter index to split as a comma seperated list </td></tr>
    <tr><td class="paramname">usemax</td><td>Limit the command to MaxTargets targets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function will return 1 when there are no more parameters to process. When this occurs, its caller should return without doing anything, otherwise it should continue into its main section of code. </dd></dl>
<p>Some lame ircds will weed out dupes using some shitty O(n^2) algorithm. By using std::set (thanks for the idea w00t) we can cut this down a ton. ...VOOODOOOO!</p>

</div>
</div>
<a id="aa9abf365c85ef9989d768c64d9913769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9abf365c85ef9989d768c64d9913769">&#9670;&nbsp;</a></span>ProcessBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandParser::ProcessBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a raw input buffer from a recvq, and process it on behalf of a user. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer line to process </td></tr>
    <tr><td class="paramname">user</td><td>The user to whom this line belongs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d3c5995f2cd122b66ff9be652be04d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3c5995f2cd122b66ff9be652be04d6">&#9670;&nbsp;</a></span>RemoveCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandParser::RemoveCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command.html">Command</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a command. </p>

</div>
</div>
<a id="aac8a07557d89569088b15e9a0277c0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8a07557d89569088b15e9a0277c0f8">&#9670;&nbsp;</a></span>TranslateUIDs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CommandParser::TranslateUIDs </td>
          <td>(</td>
          <td class="paramtype">TranslateType&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate nicknames in a string into UIDs, based on the TranslationType given. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The translation type to use for the process. </td></tr>
    <tr><td class="paramname">source</td><td>The input string </td></tr>
    <tr><td class="paramname">dest</td><td>The output string, it is safe to pass source and dest as the same variable only for translation type TR_TEXT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the number of substitutions made. Will always be 0 or 1 </dd></dl>

</div>
</div>
<a id="a15f208f21f81bf4fe661cc7512ae02f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f208f21f81bf4fe661cc7512ae02f3">&#9670;&nbsp;</a></span>TranslateUIDs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CommandParser::TranslateUIDs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TranslateType &gt;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefix_final</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_command.html">Command</a> *&#160;</td>
          <td class="paramname"><em>custom_translator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate nicknames in a list of strings into UIDs, based on the TranslateTypes given. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The translation types to use for the process. If this list is too short, TR_TEXT is assumed for the rest. </td></tr>
    <tr><td class="paramname">source</td><td>The strings to translate </td></tr>
    <tr><td class="paramname">dest</td><td>The output string </td></tr>
    <tr><td class="paramname">prefix_final</td><td>True if the final source argument should have a colon prepended (if it could contain a space) </td></tr>
    <tr><td class="paramname">custom_translator</td><td>Used to translate the parameter if the TR_CUSTOM type is found in to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the number of substitutions made. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8f0d1a1ef53adbf6d364a66051acd7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0d1a1ef53adbf6d364a66051acd7d1">&#9670;&nbsp;</a></span>cmdlist</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Commandtable CommandParser::cmdlist</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_command.html">Command</a> list, a hash_map of command names to Command* </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="command__parse_8h_source.html">command_parse.h</a></li>
<li>src/command_parse.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
