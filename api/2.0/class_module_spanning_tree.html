<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InspIRCd: ModuleSpanningTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InspIRCd
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ModuleSpanningTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="main_8h_source.html">main.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ModuleSpanningTree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_module_spanning_tree.png" usemap="#ModuleSpanningTree_map" alt=""/>
  <map id="ModuleSpanningTree_map" name="ModuleSpanningTree_map">
<area href="class_module.html" alt="Module" shape="rect" coords="71,56,204,80"/>
<area href="classclassbase.html" alt="classbase" shape="rect" coords="0,0,133,24"/>
<area href="classusecountbase.html" alt="usecountbase" shape="rect" coords="143,0,276,24"/>
</map>
 </div></div>

<p><a href="class_module_spanning_tree-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a81fd0204eb915765b6162c7b42378324"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a81fd0204eb915765b6162c7b42378324">ModuleSpanningTree</a> ()</td></tr>
<tr class="memitem:a450402b81db47b1d4bc5cb3a1110b056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a450402b81db47b1d4bc5cb3a1110b056">init</a> ()</td></tr>
<tr class="memitem:af5a03a072da6682bcee388c0381edcf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af5a03a072da6682bcee388c0381edcf8">ShowLinks</a> (<a class="el" href="class_tree_server.html">TreeServer</a> *Current, <a class="el" href="class_user.html">User</a> *user, int hops)</td></tr>
<tr class="memitem:ac5eda456bff949bd8d04ded76ccdbcec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ac5eda456bff949bd8d04ded76ccdbcec">CountServs</a> ()</td></tr>
<tr class="memitem:a2499c417f6c3a55a26285505be25dbbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a2499c417f6c3a55a26285505be25dbbd">HandleLinks</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:ae251705b9e9f4eae2e7c5cec1be59913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ae251705b9e9f4eae2e7c5cec1be59913">ShowMap</a> (<a class="el" href="class_tree_server.html">TreeServer</a> *Current, <a class="el" href="class_user.html">User</a> *user, int depth, int &amp;line, char *names, int &amp;maxnamew, char *stats)</td></tr>
<tr class="memitem:adf9e7958dac78d97ff966e18272e0467"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#adf9e7958dac78d97ff966e18272e0467">HandleMap</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:addb66eaba37f614fbe85d5367343fdcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#addb66eaba37f614fbe85d5367343fdcb">HandleSquit</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a3b1cd65454f08331bbab20241c9149d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a3b1cd65454f08331bbab20241c9149d7">HandleRemoteWhois</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a4b4f858e70fe77a4c3bd5ecce28d9569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a4b4f858e70fe77a4c3bd5ecce28d9569">DoPingChecks</a> (time_t curtime)</td></tr>
<tr class="memitem:af3a127376d84603d96587f6037568b84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af3a127376d84603d96587f6037568b84">ConnectServer</a> (<a class="el" href="class_link.html">Link</a> *x, <a class="el" href="class_autoconnect.html">Autoconnect</a> *y=NULL)</td></tr>
<tr class="memitem:af2a28dbc21df9a7e11426edc1bd0549e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af2a28dbc21df9a7e11426edc1bd0549e">ConnectServer</a> (<a class="el" href="class_autoconnect.html">Autoconnect</a> *y, bool on_timer)</td></tr>
<tr class="memitem:add489ace5c3b5d167388b69ab0e0cf80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#add489ace5c3b5d167388b69ab0e0cf80">AutoConnectServers</a> (time_t curtime)</td></tr>
<tr class="memitem:a8bc4d8ed37cbe575f7d52dd3476773c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a8bc4d8ed37cbe575f7d52dd3476773c5">DoConnectTimeout</a> (time_t curtime)</td></tr>
<tr class="memitem:a03b74a2a95d120c9a3cbc25273bcba20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a03b74a2a95d120c9a3cbc25273bcba20">HandleVersion</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a13fe5f715081953c7b0e18a7fb2bfdb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a13fe5f715081953c7b0e18a7fb2bfdb5">HandleConnect</a> (const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a8b9ebea5485dad314c40e41267094e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a8b9ebea5485dad314c40e41267094e05">RemoteMessage</a> (<a class="el" href="class_user.html">User</a> *user, const char *format,...) CUSTOM_PRINTF(3</td></tr>
<tr class="memitem:a711fba96019a9a27b0858d94afe5ea7f"><td class="memItemLeft" align="right" valign="top">void const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a711fba96019a9a27b0858d94afe5ea7f">MapOperInfo</a> (<a class="el" href="class_tree_server.html">TreeServer</a> *Current)</td></tr>
<tr class="memitem:af46c2f0ec066859a3245610a19ddcb34"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af46c2f0ec066859a3245610a19ddcb34">TimeToStr</a> (time_t secs)</td></tr>
<tr class="memitem:a186d18c39ac2a022a79f7833150ea150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a186d18c39ac2a022a79f7833150ea150">OnPreCommand</a> (std::string &amp;command, std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_local_user.html">LocalUser</a> *user, bool validated, const std::string &amp;original_line)</td></tr>
<tr class="memitem:a76c097965b919eb655c10d00f3d3860a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a76c097965b919eb655c10d00f3d3860a">OnPostCommand</a> (const std::string &amp;command, const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_local_user.html">LocalUser</a> *user, CmdResult result, const std::string &amp;original_line)</td></tr>
<tr class="memitem:a04cdfa23fcbbd8300eb8c76bad5087e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a04cdfa23fcbbd8300eb8c76bad5087e6">OnGetServerDescription</a> (const std::string &amp;servername, std::string &amp;description)</td></tr>
<tr class="memitem:a264f10a18eb1c06f8fda1e417d28a02b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a264f10a18eb1c06f8fda1e417d28a02b">OnUserConnect</a> (<a class="el" href="class_local_user.html">LocalUser</a> *source)</td></tr>
<tr class="memitem:ac55ca4b72d767729350834874535bd0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ac55ca4b72d767729350834874535bd0b">OnUserInvite</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, time_t)</td></tr>
<tr class="memitem:aeaad217ca3f56a7019bf6d4e30d9a7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#aeaad217ca3f56a7019bf6d4e30d9a7f6">OnPostTopicChange</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;topic)</td></tr>
<tr class="memitem:af8a2bb4fd3cb1b810e56ec06c1865cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#af8a2bb4fd3cb1b810e56ec06c1865cd1">OnWallops</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;text)</td></tr>
<tr class="memitem:a7048e3f4fdd4fe06cb6acae812245d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a7048e3f4fdd4fe06cb6acae812245d86">OnUserNotice</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::string &amp;text, char status, const CUList &amp;exempt_list)</td></tr>
<tr class="memitem:aa5f1a1093fda34e0e777a4a4d64bf78b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#aa5f1a1093fda34e0e777a4a4d64bf78b">OnUserMessage</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::string &amp;text, char status, const CUList &amp;exempt_list)</td></tr>
<tr class="memitem:a921129aba53cdcf25497ecb0d55ff057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a921129aba53cdcf25497ecb0d55ff057">OnBackgroundTimer</a> (time_t curtime)</td></tr>
<tr class="memitem:a6b3c027470ceb44bfe8920ff8ba75f13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a6b3c027470ceb44bfe8920ff8ba75f13">OnUserJoin</a> (<a class="el" href="class_membership.html">Membership</a> *memb, bool sync, bool created, CUList &amp;excepts)</td></tr>
<tr class="memitem:a7059dff0c2b341ecf852c7a5f3dd0a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a7059dff0c2b341ecf852c7a5f3dd0a95">OnChangeHost</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="memitem:a6d8bee42aeac03319ed27a1d5e89596c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a6d8bee42aeac03319ed27a1d5e89596c">OnChangeName</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;gecos)</td></tr>
<tr class="memitem:a380ed9f27f93fcd7b923958bf8e379ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a380ed9f27f93fcd7b923958bf8e379ae">OnChangeIdent</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;ident)</td></tr>
<tr class="memitem:a0d13bb14dec8357a2e99e31f0402b9fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a0d13bb14dec8357a2e99e31f0402b9fd">OnUserPart</a> (<a class="el" href="class_membership.html">Membership</a> *memb, std::string &amp;partmessage, CUList &amp;excepts)</td></tr>
<tr class="memitem:acbafe4fcda429c26bcc54dbea536dad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#acbafe4fcda429c26bcc54dbea536dad4">OnUserQuit</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;reason, const std::string &amp;oper_message)</td></tr>
<tr class="memitem:ac2e9651f46a462c7c49fe867085219ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ac2e9651f46a462c7c49fe867085219ea">OnUserPostNick</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;oldnick)</td></tr>
<tr class="memitem:ae17174311377f47da9f4e74ec6d1f70c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ae17174311377f47da9f4e74ec6d1f70c">OnUserKick</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_membership.html">Membership</a> *memb, const std::string &amp;reason, CUList &amp;excepts)</td></tr>
<tr class="memitem:ad4f8459faea3633f5f02d38b5945095e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ad4f8459faea3633f5f02d38b5945095e">OnRemoteKill</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, const std::string &amp;reason, const std::string &amp;operreason)</td></tr>
<tr class="memitem:a149f95817fef13dc6fe8d9ae437fcefd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a149f95817fef13dc6fe8d9ae437fcefd">OnPreRehash</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;parameter)</td></tr>
<tr class="memitem:a64acb5ffc84247f2eafd658a5070aa12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a64acb5ffc84247f2eafd658a5070aa12">OnRehash</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a1a293c7afc04ffadebfb1647210a4d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a1a293c7afc04ffadebfb1647210a4d38">OnOper</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;opertype)</td></tr>
<tr class="memitem:ae89c8415aacee53fcea3b606c871a195"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae89c8415aacee53fcea3b606c871a195"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>OnLine</b> (<a class="el" href="class_user.html">User</a> *source, const std::string &amp;host, bool adding, char linetype, long duration, const std::string &amp;reason)</td></tr>
<tr class="memitem:a2fe58bf526042bf4d5c9078bdda95c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a2fe58bf526042bf4d5c9078bdda95c17">OnAddLine</a> (<a class="el" href="class_user.html">User</a> *u, <a class="el" href="class_x_line.html">XLine</a> *x)</td></tr>
<tr class="memitem:a8f2bde1c0b1c6895d945b9ce4b3c2c5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a8f2bde1c0b1c6895d945b9ce4b3c2c5f">OnDelLine</a> (<a class="el" href="class_user.html">User</a> *u, <a class="el" href="class_x_line.html">XLine</a> *x)</td></tr>
<tr class="memitem:a149e48826401f4e9c5167fdc6bdb9347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a149e48826401f4e9c5167fdc6bdb9347">OnMode</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::vector&lt; std::string &gt; &amp;text, const std::vector&lt; TranslateType &gt; &amp;translate)</td></tr>
<tr class="memitem:aa853f28ec65cce1f74f69c68fa4596ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#aa853f28ec65cce1f74f69c68fa4596ff">OnStats</a> (char statschar, <a class="el" href="class_user.html">User</a> *user, string_list &amp;results)</td></tr>
<tr class="memitem:ada33998b7616a2c5f4d99fac47302c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ada33998b7616a2c5f4d99fac47302c17">OnSetAway</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;awaymsg)</td></tr>
<tr class="memitem:a7d749e5fd011f907cbfacab730783127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a7d749e5fd011f907cbfacab730783127">ProtoSendMode</a> (void *opaque, TargetTypeFlags target_type, void *target, const std::vector&lt; std::string &gt; &amp;modeline, const std::vector&lt; TranslateType &gt; &amp;translate)</td></tr>
<tr class="memitem:a581ddaf95950472de42cb8b5fcf06071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a581ddaf95950472de42cb8b5fcf06071">ProtoSendMetaData</a> (void *opaque, <a class="el" href="class_extensible.html">Extensible</a> *target, const std::string &amp;extname, const std::string &amp;extdata)</td></tr>
<tr class="memitem:a531e6972fae55a007174f6ede3203521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a531e6972fae55a007174f6ede3203521">OnLoadModule</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memitem:add64ad65a88310e30a23eac209cf7444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#add64ad65a88310e30a23eac209cf7444">OnUnloadModule</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memitem:ab6c573439a83e7bc15ada2a48e9cb59c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#ab6c573439a83e7bc15ada2a48e9cb59c">OnAcceptConnection</a> (int newsock, <a class="el" href="class_listen_socket.html">ListenSocket</a> *from, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *client, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *server)</td></tr>
<tr class="memitem:a45902839f2973017eae5643d27cbbda3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cull_result.html">CullResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a45902839f2973017eae5643d27cbbda3">cull</a> ()</td></tr>
<tr class="memitem:abfc5b4c004319dae82f96560ea949018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_version.html">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#abfc5b4c004319dae82f96560ea949018">GetVersion</a> ()</td></tr>
<tr class="memitem:a58a8e3fba7cfeadda4b74a9524d640a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a8e3fba7cfeadda4b74a9524d640a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Prioritize</b> ()</td></tr>
<tr class="inherit_header pub_methods_class_module"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_module')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="class_module.html">Module</a></td></tr>
<tr class="memitem:a5a240a8a9ab1813b17bcb810b24ceaea inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5a240a8a9ab1813b17bcb810b24ceaea">Module</a> ()</td></tr>
<tr class="memitem:a7c9d9c096786d127590fdd8aa2b7d681 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7c9d9c096786d127590fdd8aa2b7d681">~Module</a> ()</td></tr>
<tr class="memitem:a193075c27aee23eb8baf613ed31327b4 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a193075c27aee23eb8baf613ed31327b4">OnUserDisconnect</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="memitem:a90f0a0386640538a817ab4b461d75dba inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a90f0a0386640538a817ab4b461d75dba">OnChannelPreDelete</a> (<a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="memitem:a4c6be01493bcae74002a9e81d3ba3473 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4c6be01493bcae74002a9e81d3ba3473">OnChannelDelete</a> (<a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="memitem:a784e454c25bbea13bb6028062cd2757f inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a784e454c25bbea13bb6028062cd2757f">OnPostJoin</a> (<a class="el" href="class_membership.html">Membership</a> *)</td></tr>
<tr class="memitem:aaae6d16d1fe5d629dce9deedaa0a1b49 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aaae6d16d1fe5d629dce9deedaa0a1b49">OnModuleRehash</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;parameter)</td></tr>
<tr class="memitem:a7d39c9fabab9dea701f4a3ad2cfff37b inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7d39c9fabab9dea701f4a3ad2cfff37b">OnSendSnotice</a> (char &amp;snomask, std::string &amp;type, const std::string &amp;message)</td></tr>
<tr class="memitem:aa3bd372d9510aaeb1181e75295924649 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aa3bd372d9510aaeb1181e75295924649">OnUserPreJoin</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const char *cname, std::string &amp;privs, const std::string &amp;keygiven)</td></tr>
<tr class="memitem:a54fb5e86ea38f35095af102f40894c1b inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a54fb5e86ea38f35095af102f40894c1b">OnUserPreKick</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_membership.html">Membership</a> *memb, const std::string &amp;reason)</td></tr>
<tr class="memitem:ac0b2ffd9df24552ff78888a536faceba inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ac0b2ffd9df24552ff78888a536faceba">OnPostOper</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;opername, const std::string &amp;opertype)</td></tr>
<tr class="memitem:af351dba33f01a510e4b98ebe76efa452 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af351dba33f01a510e4b98ebe76efa452">OnInfo</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a450dc0c85646c5286f1c84f2c2d1ed14 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a450dc0c85646c5286f1c84f2c2d1ed14">OnWhois</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest)</td></tr>
<tr class="memitem:a9c2b1fed6b47eda0305f04426db05baf inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a9c2b1fed6b47eda0305f04426db05baf">OnUserPreInvite</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, time_t timeout)</td></tr>
<tr class="memitem:a6982393c29ffcd698dc42e345fbd9d84 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a6982393c29ffcd698dc42e345fbd9d84">OnUserPreMessage</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, std::string &amp;text, char status, CUList &amp;exempt_list)</td></tr>
<tr class="memitem:a1daccd21f78e44a5855d916d35873628 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a1daccd21f78e44a5855d916d35873628">OnUserPreNotice</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, std::string &amp;text, char status, CUList &amp;exempt_list)</td></tr>
<tr class="memitem:a67613e4e1a90b89b689911fa6d933b0e inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a67613e4e1a90b89b689911fa6d933b0e">OnBuildNeighborList</a> (<a class="el" href="class_user.html">User</a> *source, UserChanList &amp;include_c, std::map&lt; <a class="el" href="class_user.html">User</a> *, bool &gt; &amp;exceptions)</td></tr>
<tr class="memitem:a14c0588d2b9536f3ac984745cfe9fe0c inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a14c0588d2b9536f3ac984745cfe9fe0c">OnUserPreNick</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;newnick)</td></tr>
<tr class="memitem:a19baf615db55e3363cd3065674fc3b72 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a19baf615db55e3363cd3065674fc3b72">OnText</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::string &amp;text, char status, CUList &amp;exempt_list)</td></tr>
<tr class="memitem:aeb0d58aeef06736a367072e593116ce0 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aeb0d58aeef06736a367072e593116ce0">OnSyncUser</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_module.html">Module</a> *proto, void *opaque)</td></tr>
<tr class="memitem:a4f6ddca119f70f61a24e77b7efdeea07 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4f6ddca119f70f61a24e77b7efdeea07">OnSyncChannel</a> (<a class="el" href="class_channel.html">Channel</a> *chan, <a class="el" href="class_module.html">Module</a> *proto, void *opaque)</td></tr>
<tr class="memitem:a8b15ff09476c1edb53ecadae0cbf57ac inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b15ff09476c1edb53ecadae0cbf57ac"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>OnSyncNetwork</b> (<a class="el" href="class_module.html">Module</a> *proto, void *opaque)</td></tr>
<tr class="memitem:af2e2a4e731ead980507fd02e0b1f69b0 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af2e2a4e731ead980507fd02e0b1f69b0">OnDecodeMetaData</a> (<a class="el" href="class_extensible.html">Extensible</a> *target, const std::string &amp;extname, const std::string &amp;extdata)</td></tr>
<tr class="memitem:a33b8a6dd1c8e6f2e8e15eed14a5205e6 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a33b8a6dd1c8e6f2e8e15eed14a5205e6">OnExpireLine</a> (<a class="el" href="class_x_line.html">XLine</a> *line)</td></tr>
<tr class="memitem:afcf8e8cec05aff2e6a3c0edb45eedd6d inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afcf8e8cec05aff2e6a3c0edb45eedd6d">OnCleanup</a> (int target_type, void *item)</td></tr>
<tr class="memitem:af5c3d1cf69b8b43b133ad4bf18e110ec inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af5c3d1cf69b8b43b133ad4bf18e110ec">OnPreMode</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, const std::vector&lt; std::string &gt; &amp;parameters)</td></tr>
<tr class="memitem:abed6b1b9feca7d107da23aafe1fef9fa inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#abed6b1b9feca7d107da23aafe1fef9fa">On005Numeric</a> (std::string &amp;output)</td></tr>
<tr class="memitem:a140312a31a1e9163193dd7707707c6b8 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a140312a31a1e9163193dd7707707c6b8">OnKill</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, const std::string &amp;reason)</td></tr>
<tr class="memitem:a45ed68d2c341e59dd9acc50672d67aae inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a45ed68d2c341e59dd9acc50672d67aae">OnUserInit</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="memitem:ab05531b903581d8100ca28934eac468d inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab05531b903581d8100ca28934eac468d">OnCheckReady</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="memitem:aeee48e5f4d4efbb826f462c1e5f4d0ee inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aeee48e5f4d4efbb826f462c1e5f4d0ee">OnUserRegister</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="memitem:afe6fc87d0e8f6847eee8e216f8026c08 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afe6fc87d0e8f6847eee8e216f8026c08">OnCheckInvite</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="memitem:a23bbfae81a74a9cb3131c3e7c1f3cfe7 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a23bbfae81a74a9cb3131c3e7c1f3cfe7">OnRawMode</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const char mode, const std::string &amp;param, bool adding, int pcnt)</td></tr>
<tr class="memitem:a75601f0642212088ae40e38b186595fd inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a75601f0642212088ae40e38b186595fd">OnCheckKey</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;keygiven)</td></tr>
<tr class="memitem:ab63e9aa43689a8bac7bb27c39e430d9e inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab63e9aa43689a8bac7bb27c39e430d9e">OnCheckLimit</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="memitem:a54e86cd99c82307e8c5d19fec3b575d2 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a54e86cd99c82307e8c5d19fec3b575d2">OnCheckChannelBan</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="memitem:a029982a980048c30c5b4dec12886af76 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a029982a980048c30c5b4dec12886af76">OnCheckBan</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;mask)</td></tr>
<tr class="memitem:a329aa3d2f888266d347122df7cdab3bc inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a329aa3d2f888266d347122df7cdab3bc">OnExtBanCheck</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, char type)</td></tr>
<tr class="memitem:a83e8a040d752c423103420a814dfc868 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a83e8a040d752c423103420a814dfc868">OnChangeLocalUserHost</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="memitem:abcde3dba5bc6c5359b0bbc9964a91a1b inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#abcde3dba5bc6c5359b0bbc9964a91a1b">OnChangeLocalUserGECOS</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="memitem:aaf0fffc69b3af9695efaec60df2a1876 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aaf0fffc69b3af9695efaec60df2a1876">OnPreTopicChange</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;topic)</td></tr>
<tr class="memitem:afcc7ac64df8f7719edf402f27eefc665 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afcc7ac64df8f7719edf402f27eefc665">OnEvent</a> (<a class="el" href="class_event.html">Event</a> &amp;event)</td></tr>
<tr class="memitem:a7e0478b88aede4d02676433246543eff inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7e0478b88aede4d02676433246543eff">OnRequest</a> (<a class="el" href="class_request.html">Request</a> &amp;request)</td></tr>
<tr class="memitem:ab2a40bf5ebb638640047a5089e41c333 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab2a40bf5ebb638640047a5089e41c333">OnPassCompare</a> (<a class="el" href="class_extensible.html">Extensible</a> *ex, const std::string &amp;password, const std::string &amp;input, const std::string &amp;hashtype)</td></tr>
<tr class="memitem:a7c7a2974cb000cfcad1f7605a10d3598 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7c7a2974cb000cfcad1f7605a10d3598">OnGlobalOper</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:aa3a7c87d002fe32d4d0f46a7f438fbbb inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aa3a7c87d002fe32d4d0f46a7f438fbbb">OnPostConnect</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="memitem:a06fb27e2d4deeb16da8f0095c647aaf4 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a06fb27e2d4deeb16da8f0095c647aaf4">OnAddBan</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_channel.html">Channel</a> *channel, const std::string &amp;banmask)</td></tr>
<tr class="memitem:aca4e5d8a6167d1e9a04308b8ee95bfcf inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aca4e5d8a6167d1e9a04308b8ee95bfcf">OnDelBan</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_channel.html">Channel</a> *channel, const std::string &amp;banmask)</td></tr>
<tr class="memitem:a2c51fa77d6e129b543be22fdbc60a97f inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a2c51fa77d6e129b543be22fdbc60a97f">OnHookIO</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *, <a class="el" href="class_listen_socket.html">ListenSocket</a> *via)</td></tr>
<tr class="memitem:a1a21a204791fcd5d1fca413590d4e7f3 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a1a21a204791fcd5d1fca413590d4e7f3">OnStreamSocketAccept</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *client, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *server)</td></tr>
<tr class="memitem:a037d34dd931e81f565d50a9ace21eb69 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a037d34dd931e81f565d50a9ace21eb69">OnStreamSocketWrite</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *, std::string &amp;sendq)</td></tr>
<tr class="memitem:abc882d9221ab1e594fdb2ad32197af72 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#abc882d9221ab1e594fdb2ad32197af72">OnStreamSocketClose</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *)</td></tr>
<tr class="memitem:a043c01e212671032d40f8abed0a241f7 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a043c01e212671032d40f8abed0a241f7">OnStreamSocketConnect</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *)</td></tr>
<tr class="memitem:ae147f1677bca5523c06adc6f9d942700 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ae147f1677bca5523c06adc6f9d942700">OnStreamSocketRead</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *, std::string &amp;recvq)</td></tr>
<tr class="memitem:a6b4bdaeb323660a3b9120195f8a6cbcb inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a6b4bdaeb323660a3b9120195f8a6cbcb">OnWhoisLine</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_user.html">User</a> *dest, int &amp;numeric, std::string &amp;text)</td></tr>
<tr class="memitem:a152a4ce724c1fed088c51c12be43a62b inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a152a4ce724c1fed088c51c12be43a62b">OnGarbageCollect</a> ()</td></tr>
<tr class="memitem:a5a7c6fc1a66af63568b6a69db294a0df inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5a7c6fc1a66af63568b6a69db294a0df">OnSetConnectClass</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, <a class="el" href="struct_connect_class.html">ConnectClass</a> *myclass)</td></tr>
<tr class="memitem:a405c9943fe759d41055f7341c1d916b0 inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a405c9943fe759d41055f7341c1d916b0">OnRunTestSuite</a> ()</td></tr>
<tr class="memitem:add927647a8531cced935d19f532fe9de inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#add927647a8531cced935d19f532fe9de">OnNamesListItem</a> (<a class="el" href="class_user.html">User</a> *issuer, <a class="el" href="class_membership.html">Membership</a> *item, std::string &amp;prefixes, std::string &amp;nick)</td></tr>
<tr class="memitem:a0203afb10fbe91ec50b3babf56cd6e2f inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0203afb10fbe91ec50b3babf56cd6e2f"></a>
virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OnNumeric</b> (<a class="el" href="class_user.html">User</a> *user, unsigned int numeric, const std::string &amp;text)</td></tr>
<tr class="memitem:aced8dd06b3db2733ac012b490a84254e inherit pub_methods_class_module"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aced8dd06b3db2733ac012b490a84254e">OnSendWhoLine</a> (<a class="el" href="class_user.html">User</a> *source, const std::vector&lt; std::string &gt; &amp;params, <a class="el" href="class_user.html">User</a> *user, std::string &amp;line)</td></tr>
<tr class="inherit_header pub_methods_classusecountbase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classusecountbase')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classusecountbase.html">usecountbase</a></td></tr>
<tr class="memitem:a45fc20645148e861a3ffcb6ae769b3f5 inherit pub_methods_classusecountbase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45fc20645148e861a3ffcb6ae769b3f5"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>GetUseCount</b> () const </td></tr>
<tr class="memitem:afdd838d750d44a4c15fb490a3d42e30e inherit pub_methods_classusecountbase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdd838d750d44a4c15fb490a3d42e30e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>refcount_inc</b> () const </td></tr>
<tr class="memitem:a194edb7376fcb2bd38ed14ca87220fbe inherit pub_methods_classusecountbase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194edb7376fcb2bd38ed14ca87220fbe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>refcount_dec</b> () const </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab5817fb93fb5598ff76900df63883498"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5817fb93fb5598ff76900df63883498"></a>
<a class="el" href="class_spanning_tree_utilities.html">SpanningTreeUtilities</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Utils</b></td></tr>
<tr class="memitem:ab4e326e110785e7e8b86ccf073593ce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4e326e110785e7e8b86ccf073593ce5"></a>
<a class="el" href="class_cache_refresh_timer.html">CacheRefreshTimer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>RefreshTimer</b></td></tr>
<tr class="memitem:a3332c431147e5601e1b2634d6785d371"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module_spanning_tree.html#a3332c431147e5601e1b2634d6785d371">loopCall</a></td></tr>
<tr class="inherit_header pub_attribs_class_module"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_module')"><img src="closed.png" alt="-"/>&nbsp;Public Attributes inherited from <a class="el" href="class_module.html">Module</a></td></tr>
<tr class="memitem:a4b9d41041b7b56a786064020e9c50c75 inherit pub_attribs_class_module"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4b9d41041b7b56a786064020e9c50c75">ModuleSourceFile</a></td></tr>
<tr class="memitem:a5bbdc3c59248520549e5904bb402e2cb inherit pub_attribs_class_module"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_l_l_manager.html">DLLManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5bbdc3c59248520549e5904bb402e2cb">ModuleDLLManager</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is the main class for the spanningtree module </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a81fd0204eb915765b6162c7b42378324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleSpanningTree::ModuleSpanningTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="add489ace5c3b5d167388b69ab0e0cf80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::AutoConnectServers </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>curtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if any servers are due to be autoconnected </p>

</div>
</div>
<a class="anchor" id="af3a127376d84603d96587f6037568b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::ConnectServer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_autoconnect.html">Autoconnect</a> *&#160;</td>
          <td class="paramname"><em>y</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a server locally </p>

</div>
</div>
<a class="anchor" id="af2a28dbc21df9a7e11426edc1bd0549e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::ConnectServer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_autoconnect.html">Autoconnect</a> *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect the next autoconnect server </p>

</div>
</div>
<a class="anchor" id="ac5eda456bff949bd8d04ded76ccdbcec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ModuleSpanningTree::CountServs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts local and remote servers </p>

</div>
</div>
<a class="anchor" id="a45902839f2973017eae5643d27cbbda3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cull_result.html">CullResult</a> ModuleSpanningTree::cull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clean up prior to destruction If you override, you must call this AFTER your module's cleanup </p>

<p>Reimplemented from <a class="el" href="class_module.html#a9cf4e278594597a19264689a2d14bde0">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a8bc4d8ed37cbe575f7d52dd3476773c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::DoConnectTimeout </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>curtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if any connecting servers should timeout </p>

</div>
</div>
<a class="anchor" id="a4b4f858e70fe77a4c3bd5ecce28d9569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::DoPingChecks </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>curtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ping all local servers </p>

</div>
</div>
<a class="anchor" id="abfc5b4c004319dae82f96560ea949018"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_version.html">Version</a> ModuleSpanningTree::GetVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the version number of a <a class="el" href="class_module.html">Module</a>. The method should return a <a class="el" href="class_version.html">Version</a> object with its version information assigned via <a class="el" href="class_version.html#aaf3a196a2f6e05adc2dfb92844adcf73">Version::Version</a> </p>

<p>Implements <a class="el" href="class_module.html#ace1cba59ac54d26b4649858b2cfc6aa8">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a13fe5f715081953c7b0e18a7fb2bfdb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> ModuleSpanningTree::HandleConnect </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle CONNECT </p>

</div>
</div>
<a class="anchor" id="a2499c417f6c3a55a26285505be25dbbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::HandleLinks </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle LINKS command </p>

</div>
</div>
<a class="anchor" id="adf9e7958dac78d97ff966e18272e0467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ModuleSpanningTree::HandleMap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle MAP command </p>

</div>
</div>
<a class="anchor" id="a3b1cd65454f08331bbab20241c9149d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> ModuleSpanningTree::HandleRemoteWhois </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle remote WHOIS </p>

</div>
</div>
<a class="anchor" id="addb66eaba37f614fbe85d5367343fdcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> ModuleSpanningTree::HandleSquit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle SQUIT </p>

</div>
</div>
<a class="anchor" id="a03b74a2a95d120c9a3cbc25273bcba20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> ModuleSpanningTree::HandleVersion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle remote VERSON </p>

</div>
</div>
<a class="anchor" id="a450402b81db47b1d4bc5cb3a1110b056"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_module.html">Module</a> setup </p>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_module_exception.html">ModuleException</a></td><td>Throwing this class, or any class derived from <a class="el" href="class_module_exception.html">ModuleException</a>, causes loading of the module to abort. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ab19e59816d97db07363143c859ad0c10">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a711fba96019a9a27b0858d94afe5ea7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string ModuleSpanningTree::MapOperInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_server.html">TreeServer</a> *&#160;</td>
          <td class="paramname"><em>Current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns oper-specific MAP information </p>

</div>
</div>
<a class="anchor" id="ab6c573439a83e7bc15ada2a48e9cb59c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> ModuleSpanningTree::OnAcceptConnection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_listen_socket.html">ListenSocket</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a port accepts a connection Return MOD_RES_ACCEPT if you have used the file descriptor. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor returned from accept() </td></tr>
    <tr><td class="paramname">from</td><td>The local port the user connected to </td></tr>
    <tr><td class="paramname">client</td><td>The client IP address and port </td></tr>
    <tr><td class="paramname">server</td><td>The server IP address and port </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#aad55c981aabd9066ff5d65047d64fbaa">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a2fe58bf526042bf4d5c9078bdda95c17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnAddLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever an xline is added by a local user. This method is triggered after the line is added. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The sender of the line or NULL for local server </td></tr>
    <tr><td class="paramname">line</td><td>The xline being added </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ace17c45466526ac93a24c8a7441b59e3">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a921129aba53cdcf25497ecb0d55ff057"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnBackgroundTimer </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>curtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called once every five seconds for background processing. This timer can be used to control timed features. Its period is not accurate enough to be used as a clock, but it is gauranteed to be called at least once in any five second period, directly from the main loop of the server. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">curtime</td><td>The current timer derived from time(2) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a22aeb882a4a4cc619ebb7625ae241686">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a7059dff0c2b341ecf852c7a5f3dd0a95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnChangeHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's hostname is changed. This event triggers after the host has been set. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whos host is being changed </td></tr>
    <tr><td class="paramname">newhost</td><td>The new hostname being set </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a9f6aa4ebe19c22eb32f7a65ecbc74594">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a380ed9f27f93fcd7b923958bf8e379ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnChangeIdent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ident</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's IDENT is changed. This event triggers after the name has been set. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who's IDENT is being changed </td></tr>
    <tr><td class="paramname">gecos</td><td>The new IDENT being set on the user </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a135ab5a74a236dc4f696191b25efec2b">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a6d8bee42aeac03319ed27a1d5e89596c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnChangeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gecos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's GECOS (realname) is changed. This event triggers after the name has been set. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who's GECOS is being changed </td></tr>
    <tr><td class="paramname">gecos</td><td>The new GECOS being set on the user </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a1d41b8806e963af21486007e5f8369c3">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a8f2bde1c0b1c6895d945b9ce4b3c2c5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnDelLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever an xline is deleted MANUALLY. See OnExpireLine for expiry. This method is triggered after the line is deleted. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user removing the line or NULL for local server </td></tr>
    <tr><td class="paramname">line</td><td>the line being deleted </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#aa784e9b35582872ca8228053c93615d7">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a04cdfa23fcbbd8300eb8c76bad5087e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnGetServerDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>servername</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows modules to alter or create server descriptions Whenever a module requires a server description, for example for display in WHOIS, this function is called in all modules. You may change or define the description given in std::string &amp;description. If you do, this description will be shown in the WHOIS fields. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">servername</td><td>The servername being searched for </td></tr>
    <tr><td class="paramname">description</td><td>Alterable server description for this server </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ad73942a4fa3c80fcee0fbbe501aeae20">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a531e6972fae55a007174f6ede3203521"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnLoadModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a module is loaded. mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded "m_killwidgets.so" with "m_makewidgets.so". It is highly recommended that modules do <em>NOT</em> bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely neccessary (e.g. a module that extends the features of another module). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>A pointer to the new module </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#abedc27f4e91f68ee71ca14afa91e7145">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a149e48826401f4e9c5167fdc6bdb9347"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; TranslateType &gt; &amp;&#160;</td>
          <td class="paramname"><em>translate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after every MODE command sent from a user The dest variable contains a User* if target_type is TYPE_USER and a Channel* if target_type is TYPE_CHANNEL. The text variable contains the remainder of the mode string after the target, e.g. "+wsi" or "+ooo nick1 nick2 nick3". </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the MODEs </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the modes (User* or Channel*) </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>The actual modes and their parameters if any </td></tr>
    <tr><td class="paramname">translate</td><td>The translation types of the mode parameters </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#af616c7db4ddd687f0402a0d94ab998f7">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a1a293c7afc04ffadebfb1647210a4d38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnOper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user opers locally. The <a class="el" href="class_user.html">User</a> will contain the oper mode 'o' as this function is called after any modifications are made to the user's structure by the core. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is opering up </td></tr>
    <tr><td class="paramname">opertype</td><td>The opers type name </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#afb6f7ea0790f23d6c15ff3daf40b7f48">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a76c097965b919eb655c10d00f3d3860a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnPostCommand </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmdResult&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any command has been executed. This event occurs for all registered commands, wether they are registered in the core, or another module, but it will not occur for invalid commands (e.g. ones which do not exist within the command table). The result code returned by the command handler is provided. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command being executed </td></tr>
    <tr><td class="paramname">parameters</td><td>An array of array of characters containing the parameters for the command </td></tr>
    <tr><td class="paramname">pcnt</td><td>The nuimber of parameters passed to the command </td></tr>
    <tr><td class="paramname">user</td><td>the user issuing the command </td></tr>
    <tr><td class="paramname">result</td><td>The return code given by the command handler, one of CMD_SUCCESS or CMD_FAILURE </td></tr>
    <tr><td class="paramname">original_line</td><td>The entire original line as passed to the parser from the user </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a098c9e5b967414eb73f5f1c3eb4952e6">Module</a>.</p>

</div>
</div>
<a class="anchor" id="aeaad217ca3f56a7019bf6d4e30d9a7f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnPostTopicChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a topic has been changed. To block topic changes you must use OnPreTopicChange instead. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing the topic </td></tr>
    <tr><td class="paramname">chan</td><td>The channels who's topic is being changed </td></tr>
    <tr><td class="paramname">topic</td><td>The actual topic text </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a9a6faca7798ee9ac8a9330c79bacbcd4">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a186d18c39ac2a022a79f7833150ea150"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> ModuleSpanningTree::OnPreCommand </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>*** MODULE EVENTS *** </p>

<p>Reimplemented from <a class="el" href="class_module.html#a678967e0e769ecd295a3a272fa488af3">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a149f95817fef13dc6fe8d9ae437fcefd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnPreRehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called on rehash. This method is called prior to a /REHASH or when a SIGHUP is received from the operating system. This is called in all cases &ndash; including when this server will not execute the rehash because it is directed at a remote server.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user performing the rehash, if any. If this is server initiated, the value of this variable will be NULL. </td></tr>
    <tr><td class="paramname">parameter</td><td>The (optional) parameter given to REHASH from the user. Empty when server initiated. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a390969a3664c10646dfe13be95ac016d">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a64acb5ffc84247f2eafd658a5070aa12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnRehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called on rehash. This method is called after a rehash has completed. You should use it to reload any module configuration from the main configuration file. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user that performed the rehash, if it was initiated by a user and that user is still connected. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a214c9dcd9bbc331697d4ed7ccd173f58">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ad4f8459faea3633f5f02d38b5945095e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnRemoteKill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>operreason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when an oper wants to disconnect a remote user via KILL </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user sending the KILL </td></tr>
    <tr><td class="paramname">dest</td><td>The user being killed </td></tr>
    <tr><td class="paramname">reason</td><td>The kill reason </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ac7d0823f952be21553f6846617907a36">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ada33998b7616a2c5f4d99fac47302c17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> ModuleSpanningTree::OnSetAway </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>awaymsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user sets away or returns from being away. The away message is available as a parameter, but should not be modified. At this stage, it has already been copied into the user record. If awaymsg is empty, the user is returning from away. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user setting away </td></tr>
    <tr><td class="paramname">awaymsg</td><td>The away message of the user, or empty if returning from away </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>nonzero if the away message should be blocked - should ONLY be nonzero for LOCAL users (IS_LOCAL) (no output is returned by core) </dd></dl>

<p>Reimplemented from <a class="el" href="class_module.html#ab16f4b39fb1f4353ad2f5d8b652e7425">Module</a>.</p>

</div>
</div>
<a class="anchor" id="aa853f28ec65cce1f74f69c68fa4596ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> ModuleSpanningTree::OnStats </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string_list &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called on all /STATS commands This method is triggered for all /STATS use, including stats symbols handled by the core. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the symbol provided to /STATS </td></tr>
    <tr><td class="paramname">user</td><td>the user issuing the /STATS command </td></tr>
    <tr><td class="paramname">results</td><td>A string_list to append results into. You should put all your results into this string_list, rather than displaying them directly, so that your handler will work when remote STATS queries are received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>1 to block the /STATS from being processed by the core, 0 to allow it </dd></dl>

<p>Reimplemented from <a class="el" href="class_module.html#a6fdbb320fa09ddfc3e17249cf0f057ec">Module</a>.</p>

</div>
</div>
<a class="anchor" id="add64ad65a88310e30a23eac209cf7444"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUnloadModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a module is unloaded. mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded "m_killwidgets.so" with "m_makewidgets.so". It is highly recommended that modules do <em>NOT</em> bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely neccessary (e.g. a module that extends the features of another module). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Pointer to the module being unloaded (still valid) </td></tr>
    <tr><td class="paramname">name</td><td>The filename of the module being unloaded </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ab55ed63d022db5f011db3d8c03ef6953">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a264f10a18eb1c06f8fda1e417d28a02b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUserConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user connects. The details of the connecting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is connecting </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a3910edd1a48dfe4db141b04157627a8e">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ac55ca4b72d767729350834874535bd0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUserInvite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user has been successfully invited to a channel. You cannot prevent the invite from occuring using this function, to do that, use OnUserPreInvite instead. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user who is issuing the INVITE </td></tr>
    <tr><td class="paramname">dest</td><td>The user being invited </td></tr>
    <tr><td class="paramname">channel</td><td>The channel the user is being invited to </td></tr>
    <tr><td class="paramname">timeout</td><td>The time the invite will expire (0 == never) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ab317fe70e3a528ad41c43f5cb3e252a7">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a6b3c027470ceb44bfe8920ff8ba75f13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUserJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>created</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user joins a channel. The details of the joining user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user, and the details of the channel they have joined is available in the variable <a class="el" href="class_channel.html">Channel</a> *channel </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership being created </td></tr>
    <tr><td class="paramname">sync</td><td>This is set to true if the JOIN is the result of a network sync and the remote user is being introduced to a channel due to the network sync. </td></tr>
    <tr><td class="paramname">created</td><td>This is true if the join created the channel </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#ae4e65c3401aff9a6c68e2b2f9f2de5dd">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ae17174311377f47da9f4e74ec6d1f70c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUserKick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is kicked. If this method is called, the kick is already underway and cannot be prevented, so to prevent a kick, please use <a class="el" href="class_module.html#a54fb5e86ea38f35095af102f40894c1b">Module::OnUserPreKick</a> instead of this method. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user issuing the kick </td></tr>
    <tr><td class="paramname">user</td><td>The user being kicked </td></tr>
    <tr><td class="paramname">chan</td><td>The channel the user is being kicked from </td></tr>
    <tr><td class="paramname">reason</td><td>The kick reason </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a0a0c7ca18eadf768e69894f2995b0db7">Module</a>.</p>

</div>
</div>
<a class="anchor" id="aa5f1a1093fda34e0e777a4a4d64bf78b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUserMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUList &amp;&#160;</td>
          <td class="paramname"><em>exempt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any PRIVMSG sent from a user. The dest variable contains a User* if target_type is TYPE_USER and a Channel* if target_type is TYPE_CHANNEL. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the message </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>the text being sent by the user </td></tr>
    <tr><td class="paramname">status</td><td>The status being used, e.g. PRIVMSG #chan has status== '@', 0 to send to everyone. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a57c261f2aa608ecdad8ae704734505f7">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a7048e3f4fdd4fe06cb6acae812245d86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUserNotice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUList &amp;&#160;</td>
          <td class="paramname"><em>exempt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any NOTICE sent from a user. The dest variable contains a User* if target_type is TYPE_USER and a Channel* if target_type is TYPE_CHANNEL. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the message </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>the text being sent by the user </td></tr>
    <tr><td class="paramname">status</td><td>The status being used, e.g. NOTICE #chan has status== '@', 0 to send to everyone. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a0a7e309f4ac701329acdc0b5600ee678">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a0d13bb14dec8357a2e99e31f0402b9fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUserPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>partmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user parts a channel. The details of the leaving user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user, and the details of the channel they have left is available in the variable <a class="el" href="class_channel.html">Channel</a> *channel </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership being destroyed </td></tr>
    <tr><td class="paramname">partmessage</td><td>The part message, or an empty string (may be modified) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a100db8d416d1484716999076880f63d5">Module</a>.</p>

</div>
</div>
<a class="anchor" id="ac2e9651f46a462c7c49fe867085219ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUserPostNick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldnick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any nickchange, local or remote. This can be used to track users after nickchanges have been applied. Please note that although you can see remote nickchanges through this function, you should NOT make any changes to the <a class="el" href="class_user.html">User</a> if the user is a remote user as this may cause a desnyc. check user-&gt;server before taking any action (including returning nonzero from the method). Because this method is called after the nickchange is taken place, no return values are possible to indicate forbidding of the nick change. Use OnUserPreNick for this. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing their nick </td></tr>
    <tr><td class="paramname">oldnick</td><td>The old nickname of the user before the nickchange </td></tr>
  </table>
  </dd>
</dl>
<p>IMPORTANT: We don't update the TS if the oldnick is just a case change of the newnick!</p>

<p>Reimplemented from <a class="el" href="class_module.html#ad35164fe098f2acdec99d3e242e585e9">Module</a>.</p>

</div>
</div>
<a class="anchor" id="acbafe4fcda429c26bcc54dbea536dad4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnUserQuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oper_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user quits. The details of the exiting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user This event is only called when the user is fully registered when they quit. To catch raw disconnections, use the OnUserDisconnect method. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is quitting </td></tr>
    <tr><td class="paramname">message</td><td>The user's quit message (as seen by non-opers) </td></tr>
    <tr><td class="paramname">oper_message</td><td>The user's quit message (as seen by opers) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a467945d27be3edec8fbd0de9a37a0c31">Module</a>.</p>

</div>
</div>
<a class="anchor" id="af8a2bb4fd3cb1b810e56ec06c1865cd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::OnWallops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after every WALLOPS command. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the WALLOPS </td></tr>
    <tr><td class="paramname">text</td><td>The content of the WALLOPS message </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#aa76e89f05626000f80f205db32671d56">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a581ddaf95950472de42cb8b5fcf06071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::ProtoSendMetaData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_extensible.html">Extensible</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implemented by modules which provide the ability to link servers. These modules will implement this method, which allows metadata (extra data added to user and channel records using class <a class="el" href="class_extensible.html">Extensible</a>, Extensible::Extend, etc) to be sent to other servers on a netburst and decoded at the other end by the same module on a different server.</p>
<p>More documentation to follow soon. Please see src/modules/m_swhois.cpp for example of how to use this function. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">opaque</td><td>An opaque pointer set by the protocol module, should not be modified! </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of item to decode data for, TYPE_USER or TYPE_CHANNEL </td></tr>
    <tr><td class="paramname">target</td><td>The Channel* or User* that metadata should be sent for </td></tr>
    <tr><td class="paramname">extname</td><td>The extension name to send metadata for </td></tr>
    <tr><td class="paramname">extdata</td><td>Encoded data for this extension name, which will be encoded at the oppsite end by an identical module using OnDecodeMetaData </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a3bb9dac5417ed8538e5174ebafd25e12">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a7d749e5fd011f907cbfacab730783127"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::ProtoSendMode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TargetTypeFlags&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>modeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; TranslateType &gt; &amp;&#160;</td>
          <td class="paramname"><em>translate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implemented by modules which provide the ability to link servers. These modules will implement this method, which allows transparent sending of servermodes down the network link as a broadcast, without a module calling it having to know the format of the MODE command before the actual mode string.</p>
<p>More documentation to follow soon. Please see src/modules/m_chanprotect.cpp for examples of how to use this function.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">opaque</td><td>An opaque pointer set by the protocol module, should not be modified! </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of item to decode data for, TYPE_USER or TYPE_CHANNEL </td></tr>
    <tr><td class="paramname">target</td><td>The Channel* or User* that modes should be sent for </td></tr>
    <tr><td class="paramname">modeline</td><td>The modes and parameters to be sent </td></tr>
    <tr><td class="paramname">translate</td><td>The translation types of the mode parameters </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_module.html#a0861ead2131a6edbb77bf4be1d2104ad">Module</a>.</p>

</div>
</div>
<a class="anchor" id="a8b9ebea5485dad314c40e41267094e05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::RemoteMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to send a message to a user </p>

</div>
</div>
<a class="anchor" id="af5a03a072da6682bcee388c0381edcf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::ShowLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_server.html">TreeServer</a> *&#160;</td>
          <td class="paramname"><em>Current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shows /LINKS </p>

</div>
</div>
<a class="anchor" id="ae251705b9e9f4eae2e7c5cec1be59913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleSpanningTree::ShowMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_server.html">TreeServer</a> *&#160;</td>
          <td class="paramname"><em>Current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>maxnamew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Show MAP output to a user (recursive) </p>

</div>
</div>
<a class="anchor" id="af46c2f0ec066859a3245610a19ddcb34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ModuleSpanningTree::TimeToStr </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>secs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Display a time as a human readable string </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3332c431147e5601e1b2634d6785d371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ModuleSpanningTree::loopCall</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set to true if inside a spanningtree call, to prevent sending xlines and other things back to their source </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/m_spanningtree/<a class="el" href="main_8h_source.html">main.h</a></li>
<li>src/modules/m_spanningtree/main.cpp</li>
<li>src/modules/m_spanningtree/override_map.cpp</li>
<li>src/modules/m_spanningtree/override_squit.cpp</li>
<li>src/modules/m_spanningtree/override_stats.cpp</li>
<li>src/modules/m_spanningtree/override_whois.cpp</li>
<li>src/modules/m_spanningtree/postcommand.cpp</li>
<li>src/modules/m_spanningtree/precommand.cpp</li>
<li>src/modules/m_spanningtree/utils.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>
