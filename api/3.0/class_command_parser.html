<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>InspIRCd: CommandParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">InspIRCd
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_command_parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CommandParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="command__parse_8h_source.html">command_parse.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aafdc59c715166b00e63b5e8273428310"><td class="memItemLeft" align="right" valign="top"><a id="aafdc59c715166b00e63b5e8273428310"></a>
typedef TR1NS::unordered_map&lt; std::string, <a class="el" href="class_command.html">Command</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CommandMap</b></td></tr>
<tr class="separator:aafdc59c715166b00e63b5e8273428310"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1fd17c361d85ec13c212cbac1999b9b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a1fd17c361d85ec13c212cbac1999b9b3">CommandParser</a> ()</td></tr>
<tr class="separator:a1fd17c361d85ec13c212cbac1999b9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec74ed89ee42c6c3ccfa77d49a1e10d3"><td class="memItemLeft" align="right" valign="top">const CommandMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#aec74ed89ee42c6c3ccfa77d49a1e10d3">GetCommands</a> () const</td></tr>
<tr class="separator:aec74ed89ee42c6c3ccfa77d49a1e10d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958262cd83e39063db2b050aa05c8ca5"><td class="memItemLeft" align="right" valign="top">CmdResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a958262cd83e39063db2b050aa05c8ca5">CallHandler</a> (const std::string &amp;commandname, const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_command.html">Command</a> **cmd=NULL)</td></tr>
<tr class="separator:a958262cd83e39063db2b050aa05c8ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c230220609e9ba68025dd90a8de8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_command.html">Command</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#af7c230220609e9ba68025dd90a8de8db">GetHandler</a> (const std::string &amp;commandname)</td></tr>
<tr class="separator:af7c230220609e9ba68025dd90a8de8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ba6ca548f8a6c1d1b972e5387f48af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a70ba6ca548f8a6c1d1b972e5387f48af">ProcessBuffer</a> (std::string &amp;buffer, <a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:a70ba6ca548f8a6c1d1b972e5387f48af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192f037306b2eec9044944cc1f47268f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a192f037306b2eec9044944cc1f47268f">AddCommand</a> (<a class="el" href="class_command.html">Command</a> *f)</td></tr>
<tr class="separator:a192f037306b2eec9044944cc1f47268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3c5995f2cd122b66ff9be652be04d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a2d3c5995f2cd122b66ff9be652be04d6">RemoveCommand</a> (<a class="el" href="class_command.html">Command</a> *x)</td></tr>
<tr class="separator:a2d3c5995f2cd122b66ff9be652be04d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa92371a14ce41287b41fbc40430f49dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#aa92371a14ce41287b41fbc40430f49dc">LoopCall</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_command.html">Command</a> *handler, const std::vector&lt; std::string &gt; &amp;parameters, unsigned int splithere, int extra=-1, bool usemax=true)</td></tr>
<tr class="separator:aa92371a14ce41287b41fbc40430f49dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4e98178c6bd77c6491069c11948055"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a6e4e98178c6bd77c6491069c11948055">TranslateSingleParam</a> (TranslateType to, const std::string &amp;item, std::string &amp;dest, <a class="el" href="class_command_base.html">CommandBase</a> *custom_translator=NULL, unsigned int paramnumber=0)</td></tr>
<tr class="separator:a6e4e98178c6bd77c6491069c11948055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0708e9a3aca596233d397c180946ac25"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_parser.html#a0708e9a3aca596233d397c180946ac25">TranslateUIDs</a> (const std::vector&lt; TranslateType &gt; &amp;to, const std::vector&lt; std::string &gt; &amp;source, bool prefix_final=false, <a class="el" href="class_command_base.html">CommandBase</a> *custom_translator=NULL)</td></tr>
<tr class="separator:a0708e9a3aca596233d397c180946ac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class handles command management and parsing. It allows you to add and remove commands from the map, call command handlers by name, and chop up comma seperated parameters into multiple calls. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1fd17c361d85ec13c212cbac1999b9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd17c361d85ec13c212cbac1999b9b3">&#9670;&nbsp;</a></span>CommandParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CommandParser::CommandParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a192f037306b2eec9044944cc1f47268f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192f037306b2eec9044944cc1f47268f">&#9670;&nbsp;</a></span>AddCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandParser::AddCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command.html">Command</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new command to the commands hash </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The new <a class="el" href="class_command.html">Command</a> to add to the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the command was added </dd></dl>

</div>
</div>
<a id="a958262cd83e39063db2b050aa05c8ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958262cd83e39063db2b050aa05c8ca5">&#9670;&nbsp;</a></span>CallHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CmdResult CommandParser::CallHandler </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>commandname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_command.html">Command</a> **&#160;</td>
          <td class="paramname"><em>cmd</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the handler for a given command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandname</td><td>The command to find. This should be in uppercase. </td></tr>
    <tr><td class="paramname">parameters</td><td>Parameter list </td></tr>
    <tr><td class="paramname">user</td><td>The user to call the handler on behalf of </td></tr>
    <tr><td class="paramname">cmd</td><td>If non-NULL and the command was executed it is set to the command handler, otherwise it isn't written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This method will return CMD_SUCCESS if the command handler was found and called, and the command completeld successfully. It will return CMD_FAILURE if the command handler was found and called, but the command did not complete successfully, and it will return CMD_INVALID if the command simply did not exist at all or the wrong number of parameters were given, or the user was not privilaged enough to execute the command. </dd></dl>

</div>
</div>
<a id="aec74ed89ee42c6c3ccfa77d49a1e10d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec74ed89ee42c6c3ccfa77d49a1e10d3">&#9670;&nbsp;</a></span>GetCommands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CommandMap&amp; CommandParser::GetCommands </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a command name -&gt; Command* map containing all client to server commands </p><dl class="section return"><dt>Returns</dt><dd>A map of command handlers keyed by command names </dd></dl>

</div>
</div>
<a id="af7c230220609e9ba68025dd90a8de8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c230220609e9ba68025dd90a8de8db">&#9670;&nbsp;</a></span>GetHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_command.html">Command</a> * CommandParser::GetHandler </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>commandname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the handler function for a command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandname</td><td>The command required. Always use uppercase for this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the command handler, or NULL </dd></dl>

</div>
</div>
<a id="aa92371a14ce41287b41fbc40430f49dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92371a14ce41287b41fbc40430f49dc">&#9670;&nbsp;</a></span>LoopCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandParser::LoopCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_command.html">Command</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>splithere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extra</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usemax</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LoopCall is used to call a command handler repeatedly based on the contents of a comma seperated list. There are two ways to call this method, either with one potential list or with two potential lists. We need to handle two potential lists for JOIN, because a JOIN may contain two lists of items at once: the channel names and their keys as follows:</p>
<p>JOIN #chan1,#chan2,#chan3 key1,,key3</p>
<p>Therefore, we need to deal with both lists concurrently. If there are two lists then the method reads them both together until the first runs out of tokens. With one list it is much simpler, and is used in NAMES, WHOIS, PRIVMSG etc.</p>
<p>If there is only one list and there are duplicates in it, then the command handler is only called for unique items. Entries are compared using "irc comparison". If the usemax parameter is true (the default) the function only parses until it reaches ServerInstance-&gt;Config-&gt;MaxTargets number of targets, to stop abuse via spam.</p>
<p>The OnPostCommand hook is executed for each item after it has been processed by the handler, with the original line parameter being empty (to indicate that the command in that form was created by this function). This only applies if the user executing the command is local.</p>
<p>If there are two lists and the second list runs out of tokens before the first list then parameters[extra] will be an EMPTY string when Handle() is called for the remaining tokens in the first list, even if it is in the middle of parameters[]! Moreover, empty tokens in the second list are allowed, and those will also result in the appropiate entry being empty in parameters[]. This is different than what command handlers usually expect; the command parser only allows an empty param as the last item in the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who sent the command </td></tr>
    <tr><td class="paramname">handler</td><td>The command handler to call for each parameter in the list </td></tr>
    <tr><td class="paramname">parameters</td><td>Parameter list as a vector of strings </td></tr>
    <tr><td class="paramname">splithere</td><td>The first parameter index to split as a comma seperated list </td></tr>
    <tr><td class="paramname">extra</td><td>The second parameter index to split as a comma seperated list, or -1 (the default) if there is only one list </td></tr>
    <tr><td class="paramname">usemax</td><td>True to limit the command to MaxTargets targets (default), or false to process all tokens </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns true when it identified a list in the given parameter and finished calling the command handler for each entry on the list. When this occurs, the caller should return without doing anything, otherwise it should continue into its main section of code. </dd></dl>
<p>Some lame ircds will weed out dupes using some shitty O(n^2) algorithm. By using std::set (thanks for the idea w00t) we can cut this down a ton. ...VOOODOOOO!</p>
<p>Only check for duplicates if there is one list (allow them in JOIN).</p>

</div>
</div>
<a id="a70ba6ca548f8a6c1d1b972e5387f48af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ba6ca548f8a6c1d1b972e5387f48af">&#9670;&nbsp;</a></span>ProcessBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandParser::ProcessBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a raw input buffer from a recvq, and process it on behalf of a user. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer line to process </td></tr>
    <tr><td class="paramname">user</td><td>The user to whom this line belongs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d3c5995f2cd122b66ff9be652be04d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3c5995f2cd122b66ff9be652be04d6">&#9670;&nbsp;</a></span>RemoveCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandParser::RemoveCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command.html">Command</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a command. </p>

</div>
</div>
<a id="a6e4e98178c6bd77c6491069c11948055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4e98178c6bd77c6491069c11948055">&#9670;&nbsp;</a></span>TranslateSingleParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommandParser::TranslateSingleParam </td>
          <td>(</td>
          <td class="paramtype">TranslateType&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_command_base.html">CommandBase</a> *&#160;</td>
          <td class="paramname"><em>custom_translator</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>paramnumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate a single item based on the TranslationType given. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The translation type to use for the process </td></tr>
    <tr><td class="paramname">item</td><td>The input string </td></tr>
    <tr><td class="paramname">dest</td><td>The output string. The translation result will be appended to this string </td></tr>
    <tr><td class="paramname">custom_translator</td><td>Used to translate the parameter if the translation type is TR_CUSTOM, if NULL, TR_CUSTOM will act like TR_TEXT </td></tr>
    <tr><td class="paramname">paramnumber</td><td>The index of the parameter we are translating. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0708e9a3aca596233d397c180946ac25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0708e9a3aca596233d397c180946ac25">&#9670;&nbsp;</a></span>TranslateUIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CommandParser::TranslateUIDs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TranslateType &gt; &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefix_final</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_command_base.html">CommandBase</a> *&#160;</td>
          <td class="paramname"><em>custom_translator</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate nicknames in a list of strings into UIDs, based on the TranslateTypes given. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The translation types to use for the process. If this list is too short, TR_TEXT is assumed for the rest. </td></tr>
    <tr><td class="paramname">source</td><td>The strings to translate </td></tr>
    <tr><td class="paramname">prefix_final</td><td>True if the final source argument should have a colon prepended (if it could contain a space) </td></tr>
    <tr><td class="paramname">custom_translator</td><td>Used to translate the parameter if the translation type is TR_CUSTOM, if NULL, TR_CUSTOM will act like TR_TEXT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dest The output string </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="command__parse_8h_source.html">command_parse.h</a></li>
<li>src/command_parse.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
